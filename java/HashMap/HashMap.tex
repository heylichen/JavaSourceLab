\documentclass[UTF8,11pt]{ctexbook}
\usepackage{titlesec}		%标题样式
\usepackage{geometry}		%页面间距
\usepackage{microtype}		%单词间距自动调整
\usepackage{graphicx}		%插入图片   
\usepackage{mathptmx}		%使用times字体
\usepackage{fancyhdr}		%页眉页脚，不用中文
\usepackage{clrscode3e}		%clrs package
\usepackage{lipsum} % for dummy text
\usepackage{enumitem}

%缩进
\setlength\parindent{0pt}
%行间距
\linespread{1}
%段间距
\setlength{\parskip}{1em} 
%页眉
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{ \markboth{#1}{} }	%页面用英文, 小写
\renewcommand{\sectionmark}[1]{ \markright{#1}{} }

\renewcommand\headrulewidth{0pt}
\lhead{chapter \thechapter \ \leftmark}
\rhead{\thesection \ \rightmark}
%页面间距
\newgeometry{left = 3 cm, right=3 cm,top=1.5cm,bottom=1.5cm}
%文中一些字体
\newcommand{\bold}[1]{\textbf{#1}}
\newcommand{\bolditalic}[1]{\textbf{\textit{#1}}}
\newcommand{\point}[1]{\noindent{\textbf{#1}}}

\newenvironment{myitemize}
{ \begin{itemize}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}     }
	{ \end{itemize}                  }

\newenvironment{myenumerate}
{ \begin{enumerate}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}     }
	{ \end{enumerate}                  }


%重定义chapter, section的样式及行间距，不用cbook的默认样式
\titlespacing{\chapter}{0pt}{2.5ex plus 1ex minus .2ex}{1.3ex plus .2ex}
\titleformat{\chapter}{\huge\bfseries}{\thechapter}{2em}{}
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}

\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle = \ttfamily\small,
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
 


\begin{document}
	\chapter{Class HashMap$<$K,V$>$}
	\section{javaDoc}
	
	Type Parameters:\\
	K - the type of keys maintained by this map\\
	V - the type of mapped values
	\par	
	Hash table based implementation of the \bold{Map} interface. This implementation provides all of the optional map operations,
	and permits \bold{null} values and the \bold{null} key. (The \bold{HashMap} class is roughly equivalent to \bold{Hashtable},
	except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, 
	it does not guarantee that the order will remain constant over time.
	\par
	This implementation provides constant-time performance for the basic operations (\bold{get} and \bold{put}),
	assuming the hash function disperses the elements properly among the buckets. Iteration over collection views
	requires time proportional to the "capacity" of the \bold{HashMap} instance (the number of buckets) plus its
	size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high
	(or the load factor too low) if iteration performance is important.
	\par
	An instance of \bold{HashMap} has two parameters that affect its performance: initial capacity and load factor.
	The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the
	time the hash table is created. The load factor is a measure of how full the hash table is allowed to \bold{get}
	before its capacity is automatically increased. When the number of entries in the hash table exceeds the 
	product of the load factor and the current capacity, the hash table is rehashed (that is, internal data 
	structures are rebuilt) so that the hash table has approximately twice the number of buckets.
	\par
	As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher 
	values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the 
	\bold{HashMap} class, including \bold{get}  and \bold{put} ). The expected number of entries in the map and
	its load factor should be taken into account when setting its initial capacity, so as to minimize the number
	of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the
	load factor, no rehash operations will ever occur.
	\par 
	If many mappings are to be stored in a \bold{HashMap} instance, creating it with a sufficiently large capacity
	will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed
	to grow the table. Note that using many keys with the same  \bold{hashCode()}  is a sure way to slow down
	performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison
	order among keys to help break ties.
	\par
	\point{Note that this implementation is not synchronized.} If multiple threads access a hash map concurrently,
	 and at least one of the threads modifies the map structurally, it must be synchronized externally.
	(A structural modification is any operation that adds or deletes one or more mappings; merely changing the
	value associated with a key that an instance already contains is not a structural modification.) This is
	typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such 
	object exists, the map should be "wrapped" using the Collections.synchronizedMap method. This is best 
	done at creation time, to prevent accidental unsynchronized access to the map:
	\par
	
	\begin{lstlisting}[ language=Java]
	Map m = Collections.synchronizedMap(new HashMap(...));
	\end{lstlisting}
	
	The iterators returned by all of this class's "collection view methods" are fail-fast: if the map is structurally
	 modified at any time after the iterator is created, in any way except through the iterator's own remove method,
	the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the 
	iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined
	time in the future.
	\par
	
	Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible 
	to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators
	 throw  \bold{ConcurrentModificationException} on a best-effort basis. Therefore, it would be wrong to 
	 write a program that depended on this exception for its correctness: the fail-fast behavior of iterators
	  should be used only to detect bugs.
	\par
	
	This class is a member of the Java Collections Framework.  

	\section{Implementation notes.} 
	This map usually acts as a binned (bucketed) hash table, but
	when bins get too large, they are transformed into bins of
	TreeNodes, each structured similarly to those in
	java.util.TreeMap. Most methods try to use normal bins, but
	relay to TreeNode methods when applicable (simply by checking
	instanceof a node).  Bins of TreeNodes may be traversed and
	used like any others, but additionally support faster lookup
	when overpopulated. However, since the vast majority of bins in
	normal use are not overpopulated, checking for existence of
	tree bins may be delayed in the course of table methods.
	\par
	Tree bins (i.e., bins whose elements are all TreeNodes) are
	ordered primarily by hashCode, but in the case of ties, if two
	elements are of the same "class C implements Comparable$<$C$>$",
	type then their compareTo method is used for ordering. (We
	conservatively check generic types via reflection to validate
	this -- see method comparableClassFor).  The added complexity
	of tree bins is worthwhile in providing worst-case O(log n)
	operations when keys either have distinct hashes or are
	orderable, Thus, performance degrades gracefully under
	accidental or malicious usages in which hashCode() methods
	return values that are poorly distributed, as well as those in
	which many keys share a hashCode, so long as they are also
	Comparable. (If neither of these apply, we may waste about a
	factor of two in time and space compared to taking no
	precautions. But the only known cases stem from poor user
	programming practices that are already so slow that this makes
	little difference.)
	\par	
	Because TreeNodes are about twice the size of regular nodes, we
	use them only when bins contain enough nodes to warrant use
	(see $TREEIFY\_THRESHOLD$). And when they become too small (due to
	removal or resizing) they are converted back to plain bins.  In
	usages with well-distributed user hashCodes, tree bins are
	rarely used.  Ideally, under random hashCodes, the frequency of
	nodes in bins follows a Poisson distribution
	(http://en.wikipedia.org/wiki/Poisson\_distribution) with a
	parameter of about 0.5 on average for the default resizing
	threshold of 0.75, although with a large variance because of
	resizing granularity. Ignoring variance, the expected
	occurrences of list size k are $(exp(-0.5) * pow(0.5, k) /
	factorial(k))$. The first values are:
	\par 
	0:    0.60653066\\
	1:    0.30326533\\
	2:    0.07581633\\
	3:    0.01263606\\
	4:    0.00157952\\
	5:    0.00015795\\
	6:    0.00001316\\
	7:    0.00000094\\
	8:    0.00000006\\
	more: less than 1 in ten million
	\par
	
	The root of a tree bin is normally its first node.  However,
	sometimes (currently only upon Iterator.remove), the root might
	be elsewhere, but can be recovered following parent links
	(method TreeNode.root()).
	
	All applicable internal methods accept a hash code as an
	argument (as normally supplied from a public method), allowing
	them to call each other without recomputing user hashCodes.
	Most internal methods also accept a "tab" argument, that is
	normally the current table, but may be a new or old one when
	resizing or converting.
	
	When bin lists are treeified, split, or untreeified, we keep
	them in the same relative access/traversal order (i.e., field
	Node.next) to better preserve locality, and to slightly
	simplify handling of splits and traversals that invoke
	iterator.remove. When using comparators on insertion, to keep a
	total ordering (or as close as is required here) across
	rebalancings, we compare classes and identityHashCodes as
	tie-breakers.
	
	The use and transitions among plain vs tree modes is
	complicated by the existence of subclass LinkedHashMap. See
	below for hook methods defined to be invoked upon insertion,
	removal and access that allow LinkedHashMap internals to
	otherwise remain independent of these mechanics. (This also
	requires that a map instance be passed to some utility methods
	that may create new nodes.)
	
	The concurrent-programming-like SSA-based coding style helps
	avoid aliasing errors amid all of the twisty pointer operations.
	
\section{source code understanding}

\end{document}